"use strict";(self.webpackChunkcodeshift_community=self.webpackChunkcodeshift_community||[]).push([[2794],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return d}});var r=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function u(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var p=r.createContext({}),s=function(e){var t=r.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},c=function(e){var t=s(e.components);return r.createElement(p.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},l=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,p=e.parentName,c=u(e,["components","mdxType","originalType","parentName"]),l=s(n),d=o,f=l["".concat(p,".").concat(d)]||l[d]||m[d]||i;return n?r.createElement(f,a(a({ref:t},c),{},{components:n})):r.createElement(f,a({ref:t},c))}));function d(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,a=new Array(i);a[0]=l;var u={};for(var p in t)hasOwnProperty.call(t,p)&&(u[p]=t[p]);u.originalType=e,u.mdxType="string"==typeof e?e:o,a[1]=u;for(var s=2;s<i;s++)a[s]=n[s];return r.createElement.apply(null,a)}return r.createElement.apply(null,n)}l.displayName="MDXCreateElement"},1082:function(e,t,n){n.r(t),n.d(t,{assets:function(){return c},contentTitle:function(){return p},default:function(){return d},frontMatter:function(){return u},metadata:function(){return s},toc:function(){return m}});var r=n(3117),o=n(102),i=(n(7294),n(3905)),a=["components"],u={id:"prompting-for-human-input",title:"Prompting for human input",slug:"/prompting-for-human-input"},p=void 0,s={unversionedId:"guides/prompting-for-human-input",id:"guides/prompting-for-human-input",title:"Prompting for human input",description:"When writing codemods, you might encounter a scenario where a specific migration might require human eyes, might not be possible or even not worth the amount of work required.",source:"@site/docs/guides/prompting-for-human-input.mdx",sourceDirName:"guides",slug:"/prompting-for-human-input",permalink:"/docs/prompting-for-human-input",editUrl:"https://github.com/CodeshiftCommunity/CodeshiftCommunity/edit/main/website/docs/guides/prompting-for-human-input.mdx",tags:[],version:"current",frontMatter:{id:"prompting-for-human-input",title:"Prompting for human input",slug:"/prompting-for-human-input"},sidebar:"docs",previous:{title:"When not to codemod",permalink:"/docs/when-not-to-codemod"},next:{title:"CSS codemods via PostCSS",permalink:"/docs/css-codemods"}},c={},m=[{value:"Inserting a comment",id:"inserting-a-comment",level:2}],l={toc:m};function d(e){var t=e.components,n=(0,o.Z)(e,a);return(0,i.kt)("wrapper",(0,r.Z)({},l,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"When writing codemods, you might encounter a scenario where a specific migration might require human eyes, might not be possible or even ",(0,i.kt)("a",{parentName:"p",href:"/docs/when-not-to-codemod"},"not worth the amount of work required"),"."),(0,i.kt)("p",null,"In these scenarios, it's usually the best to migrate as much as you can and bail-out by ",(0,i.kt)("strong",{parentName:"p"},"prompting for human input"),"."),(0,i.kt)("p",null,"Or in other words: ",(0,i.kt)("strong",{parentName:"p"},'"Insert a comment"'),"."),(0,i.kt)("p",null,"Inserting comments as codemod output is a completely valid thing to do and highlights to maintainers that they need to manually complete the migration.\nWhen leaving comments, it's helpful to be as descriptive as possible, including all or as much of the context required for the maintainer."),(0,i.kt)("p",null,"Comments are also helpful because when a PR is raised, these prompts can easily be seen in the diff and actioned at the maintainers discression. The key is to make the surface area of your codemod known and let maintainers know where they're needed."),(0,i.kt)("h2",{id:"inserting-a-comment"},"Inserting a comment"),(0,i.kt)("p",null,"Let's say your component now requires an additional prop ",(0,i.kt)("inlineCode",{parentName:"p"},"securityToken")," to function safely, but you need a user to manually enter the token.\nThis is a great candidate for prompting for user input."),(0,i.kt)("p",null,"Let's write a transform to do that:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"export default function transformer(file, { jscodeshift: j }, options) {\n  const source = j(file.source);\n\n  const newProp = source\n    .find(j.JSXIdentifier)\n    .filter(path => path.node.name === 'securityToken')\n    .forEach(path => {\n      path.value.comments = path.value.comments || [];\n      path.value.comments.push(\n        j.commentBlock(`\n        * TODO (Codemod generated): Please provide a security token.\n        * Visit https://www.my-project/security/tokens to generate a valid token.\n      `),\n      );\n    });\n\n  return source.toSource();\n}\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Input:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx"},"import React from 'react';\nimport MyComponent from '../components/my-module';\n\nconst App = props => {\n  return <div {...props} securityToken=\"???\" />;\n};\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Output:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-diff"},"import React from 'react';\nimport MyComponent from '../components/my-module';\n\n+/**\n+ * TODO (Codemod generated): Please provide a security token.\n+ * Visit https://www.my-project/security/tokens to generate a valid token.\n+ */\nconst App = props => {\n  return <div {...props} securityToken=\"???\" />;\n};\n")))}d.isMDXComponent=!0}}]);