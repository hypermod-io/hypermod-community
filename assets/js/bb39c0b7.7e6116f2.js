"use strict";(self.webpackChunkcodeshift_community=self.webpackChunkcodeshift_community||[]).push([[1966],{3905:function(e,n,t){t.d(n,{Zo:function(){return c},kt:function(){return f}});var r=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function p(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var s=r.createContext({}),l=function(e){var n=r.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},c=function(e){var n=l(e.components);return r.createElement(s.Provider,{value:n},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},m=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,c=p(e,["components","mdxType","originalType","parentName"]),u=l(t),m=a,f=u["".concat(s,".").concat(m)]||u[m]||d[m]||o;return t?r.createElement(f,i(i({ref:n},c),{},{components:t})):r.createElement(f,i({ref:n},c))}));function f(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,i=new Array(o);i[0]=m;var p={};for(var s in n)hasOwnProperty.call(n,s)&&(p[s]=n[s]);p.originalType=e,p[u]="string"==typeof e?e:a,i[1]=p;for(var l=2;l<o;l++)i[l]=t[l];return r.createElement.apply(null,i)}return r.createElement.apply(null,t)}m.displayName="MDXCreateElement"},3658:function(e,n,t){t.r(n),t.d(n,{assets:function(){return s},contentTitle:function(){return i},default:function(){return d},frontMatter:function(){return o},metadata:function(){return p},toc:function(){return l}});var r=t(3117),a=(t(7294),t(3905));const o={id:"typescript",title:"TypeScript",slug:"/typescript",description:"Learn how to write codemods to modify common TypeScript. This guide will teach you how to update variable and interface types using jscodeshift.",keywords:["typescript","codemod","codemorph","jscodeshift"]},i=void 0,p={unversionedId:"recipes/typescript",id:"recipes/typescript",title:"TypeScript",description:"Learn how to write codemods to modify common TypeScript. This guide will teach you how to update variable and interface types using jscodeshift.",source:"@site/docs/recipes/typescript.mdx",sourceDirName:"recipes",slug:"/typescript",permalink:"/docs/typescript",draft:!1,editUrl:"https://github.com/hypermod-io/hypermod-community/edit/main/website/docs/recipes/typescript.mdx",tags:[],version:"current",frontMatter:{id:"typescript",title:"TypeScript",slug:"/typescript",description:"Learn how to write codemods to modify common TypeScript. This guide will teach you how to update variable and interface types using jscodeshift.",keywords:["typescript","codemod","codemorph","jscodeshift"]},sidebar:"docs",previous:{title:"React & JSX",permalink:"/docs/react"}},s={},l=[{value:"Types",id:"types",level:2},{value:"Creating a type annotation",id:"creating-a-type-annotation",level:3},{value:"Union types",id:"union-types",level:3},{value:"Arrays",id:"arrays",level:3},{value:"Interfaces",id:"interfaces",level:2},{value:"Renaming an interface",id:"renaming-an-interface",level:3},{value:"Adding interface properties",id:"adding-interface-properties",level:3},{value:"Modifying interface properties",id:"modifying-interface-properties",level:3},{value:"Optional properties",id:"optional-properties",level:3},{value:"Extending other interfaces",id:"extending-other-interfaces",level:3},{value:"Annotations",id:"annotations",level:2},{value:"Adding types to variables",id:"adding-types-to-variables",level:3}],c={toc:l},u="wrapper";function d(e){let{components:n,...t}=e;return(0,a.kt)(u,(0,r.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"If you're looking to modify TypeScript code in bulk, jscodeshift can be incredibly helpful.\nIn this guide, we'll explore how you can use jscodeshift to modify common TypeScript syntaxes.\nWhether you're looking to update the types of variables or interfaces, this guide will provide you with the knowledge and tools you need to get started."),(0,a.kt)("admonition",{type:"tip"},(0,a.kt)("p",{parentName:"admonition"},"Remember to use the ",(0,a.kt)("inlineCode",{parentName:"p"},"ts")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"tsx")," parser when modifying TypeScript files.")),(0,a.kt)("h2",{id:"types"},"Types"),(0,a.kt)("p",null,"TypeScript ",(0,a.kt)("a",{parentName:"p",href:"https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#type-aliases"},"type aliases")," allow you to give a name to a specific type or combination of types,\nwhich can be reused throughout your code. A type alias is like a shortcut that\nallows you to define a new name for a more complex type or set of types,\nmaking your code more concise and easier to read."),(0,a.kt)("p",null,"In jscodeshift, these are represented by the node: ",(0,a.kt)("inlineCode",{parentName:"p"},"TSTypeAliasDeclaration"),"."),(0,a.kt)("h3",{id:"creating-a-type-annotation"},"Creating a type annotation"),(0,a.kt)("p",null,"If you wanted to construct a new type, you could do so using one of the TypeScript's ",(0,a.kt)("a",{parentName:"p",href:"https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#the-primitives-string-number-and-boolean"},"primitive types"),"."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"j.tsBooleanKeyword()"),": ",(0,a.kt)("inlineCode",{parentName:"li"},"boolean")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"j.tsStringKeyword()"),": ",(0,a.kt)("inlineCode",{parentName:"li"},"string")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"j.tsNumberKeyword()"),": ",(0,a.kt)("inlineCode",{parentName:"li"},"number"))),(0,a.kt)("p",null,"In addition, TypeScript provides a range of basic types."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"j.tsNullKeyword()"),": ",(0,a.kt)("inlineCode",{parentName:"li"},"null")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"j.tsAnyKeyword()"),": ",(0,a.kt)("inlineCode",{parentName:"li"},"any")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"j.tsUnknownKeyword()"),": ",(0,a.kt)("inlineCode",{parentName:"li"},"unknown")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"j.tsVoidKeyword()"),": ",(0,a.kt)("inlineCode",{parentName:"li"},"void"))),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"export default function transformer(file, { jscodeshift: j }, options) {\n  const source = j(file.source);\n\n  // Build a new type\n  const newType = j.tsTypeAliasDeclaration(\n    j.identifier('Potato'), // type name \"potato\"\n    j.tsBooleanKeyword() // boolean type annotation\n  );\n\n  // Insert it at the top of the document\n  source.get().node.program.body.unshift(newType);\n\n  return source.toSource();\n}\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Output:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"type Potato = boolean;\n")),(0,a.kt)("h3",{id:"union-types"},"Union types"),(0,a.kt)("p",null,"As we know with TypeScript, it's possible for different type annotations to be combined using ",(0,a.kt)("a",{parentName:"p",href:"https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#union-types"},"union types"),".\nThese are represented with the ",(0,a.kt)("inlineCode",{parentName:"p"},"j.TSUnionType")," node."),(0,a.kt)("p",null,"To construct a union type containing two arbitrary strings, you could do the following."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"export default function transformer(file, { jscodeshift: j }, options) {\n  const source = j(file.source);\n\n  // Build a new type\n  const newType = j.tsTypeAliasDeclaration(\n    j.identifier('Potato'), // type name \"potato\"\n    // Create a union type with two components\n    j.tsUnionType([\n      j.tsLiteralType(j.stringLiteral('foo')),\n      j.tsLiteralType(j.stringLiteral('bar')),\n    ])\n  );\n\n  // Insert it at the top of the document\n  source.get().node.program.body.unshift(newType);\n\n  return source.toSource();\n}\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Output:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"type Potato = 'foo' | 'bar';\n")),(0,a.kt)("h3",{id:"arrays"},"Arrays"),(0,a.kt)("p",null,"Similary, ",(0,a.kt)("a",{parentName:"p",href:"https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#arrays"},"TypeScript arrays")," can be constructed\nby using the ",(0,a.kt)("inlineCode",{parentName:"p"},"j.tsArrayType()")," and passing in one of the primitive types mentioned above."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"export default function transformer(file, { jscodeshift: j }, options) {\n  const source = j(file.source);\n\n  // Build a new type\n  const newType = j.tsTypeAliasDeclaration(\n    j.identifier('Potato'), // type name \"potato\"\n    j.tsArrayType(j.tsStringKeyword()) // array of strings type annotation\n  );\n\n  // Insert it at the top of the document\n  source.get().node.program.body.unshift(newType);\n\n  return source.toSource();\n}\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Output:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"type Potato = string[];\n")),(0,a.kt)("h2",{id:"interfaces"},"Interfaces"),(0,a.kt)("p",null,"A TypeScript ",(0,a.kt)("inlineCode",{parentName:"p"},"interface")," is known as a ",(0,a.kt)("inlineCode",{parentName:"p"},"TSInterfaceDeclaration"),". These can me found and modified the same as any other node."),(0,a.kt)("h3",{id:"renaming-an-interface"},"Renaming an interface"),(0,a.kt)("p",null,"For example, if you wanted to modify the name of a particular interface you could do the following."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"const oldName = 'Lunch';\nconst newName = 'Breakfast';\n\nexport default function transformer(file, { jscodeshift: j }, options) {\n  const source = j(file.source);\n\n  source\n    .find(j.TSInterfaceDeclaration, { id: { name: oldName }}) // Find all TSInterfacDeclarations with the name \"Lunch\"\n    .forEach(path => path.node.id.name = newName); // Replace it with \"Breakfast\"\n\n  return source.toSource();\n}\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Input:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"interface Lunch {\n  cheese: string;\n  burger: number;\n}\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Output:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-diff"},"-interface Lunch {\n+interface Breakfast {\n  cheese: string;\n  burger: number;\n}\n")),(0,a.kt)("h3",{id:"adding-interface-properties"},"Adding interface properties"),(0,a.kt)("p",null,"A property of interface is known as a ",(0,a.kt)("inlineCode",{parentName:"p"},"TSPropertySignature"),", representing the individual members which make up the ",(0,a.kt)("inlineCode",{parentName:"p"},"interface")," itself.\n",(0,a.kt)("inlineCode",{parentName:"p"},"TSPropertySignatures")," simply wrap a ",(0,a.kt)("inlineCode",{parentName:"p"},"TSTypeAnnotation")," which we have already seen in above."),(0,a.kt)("p",null,"Adding a property to an existing ",(0,a.kt)("inlineCode",{parentName:"p"},"interface")," includes modifying the ",(0,a.kt)("inlineCode",{parentName:"p"},"body")," array of the ",(0,a.kt)("inlineCode",{parentName:"p"},"InterfaceDeclaration"),".\nFor example, to add ",(0,a.kt)("inlineCode",{parentName:"p"},"icecream: string")," you could do the following."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"export default function transformer(file, { jscodeshift: j }, options) {\n  const source = j(file.source);\n\n  source\n    .find(j.TSInterfaceDeclaration, { id: { name: oldName }}) // Find all TSInterfacDeclarations with the name \"Lunch\"\n    .forEach(path => {\n      // Insert a new property called 'icecream' with a `string` primitive type\n      path.node.body.body = [\n        ...path.node.body.body,\n        j.tsPropertySignature(j.identifier('icecream'), j.tsTypeAnnotation(j.tsStringKeyword()))\n      ];\n    });\n\n\n  return source.toSource();\n}\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Input:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"interface Lunch {\n  cheese: string;\n  burger: number;\n}\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Output:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-diff"},"interface Lunch {\n  cheese: string;\n  burger: number;\n+ icecream: string;\n}\n")),(0,a.kt)("h3",{id:"modifying-interface-properties"},"Modifying interface properties"),(0,a.kt)("p",null,"Modifying interface properties can be a lot more straightforward since you can simply\nfilter by the interface and property name, then simply replace the ",(0,a.kt)("inlineCode",{parentName:"p"},"typeAnnotation"),"."),(0,a.kt)("p",null,"For example, if we wanted to replace the ",(0,a.kt)("inlineCode",{parentName:"p"},"TSTypeAnnotation")," of the ",(0,a.kt)("inlineCode",{parentName:"p"},"icecream")," property with\na string literal type ",(0,a.kt)("inlineCode",{parentName:"p"},"vanilla")," instead of a ",(0,a.kt)("inlineCode",{parentName:"p"},"string")," we could do the following."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"export default function transformer(file, { jscodeshift: j }, options) {\n  const source = j(file.source);\n\n  source\n    .find(j.TSInterfaceDeclaration, { id: { name: 'Lunch' }}) // Find all TSInterfacDeclarations with the name \"Lunch\"\n    .find(j.TSPropertySignature, { key: { name: 'icecream' }}) // Find all TSPropertySignatures with the name \"icecream\"\n    .forEach(path => {\n      // Replace the type annotation with a string literal type 'vanilla'\n      path.node.typeAnnotation = j.tsTypeAnnotation(j.tsLiteralType(j.stringLiteral('vanilla')));\n    });\n\n  return source.toSource();\n}\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Input:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"interface Lunch {\n  cheese: string;\n  burger: number;\n  icecream: string;\n}\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Output:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-diff"},"interface Lunch {\n  cheese: string;\n  burger: number;\n+ icecream: 'vanilla';\n}\n")),(0,a.kt)("h3",{id:"optional-properties"},"Optional properties"),(0,a.kt)("p",null,"In TypeScript, interface properties can be marked as ",(0,a.kt)("inlineCode",{parentName:"p"},"optional")," with the ",(0,a.kt)("inlineCode",{parentName:"p"},"?")," keyword.\nThe same can be done in a codemod by setting the ",(0,a.kt)("inlineCode",{parentName:"p"},"optional")," argument when creating the node."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"export default function transformer(file, { jscodeshift: j }, options) {\n  const source = j(file.source);\n\n  source\n    .find(j.TSInterfaceDeclaration, { id: { name: 'Lunch' }}) // Find all TSInterfacDeclarations with the name \"Lunch\"\n    .forEach(path => {\n      // Insert a new property called 'icecream' with a `string` primitive type\n      path.node.body.body = [\n        ...path.node.body.body,\n        j.tsPropertySignature(\n          j.identifier('icecream'), j.tsTypeAnnotation(j.tsStringKeyword())),\n          true // specifies that the icecream property is optional\n      ];\n    });\n\n  return source.toSource();\n}\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Input:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"interface Lunch {\n  cheese: string;\n  burger: number;\n}\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Output:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-diff"},"interface Lunch {\n  cheese: string;\n  burger: number;\n+ icecream?: string;\n}\n")),(0,a.kt)("h3",{id:"extending-other-interfaces"},"Extending other interfaces"),(0,a.kt)("p",null,"Interfaces can extend other interfaces. As an AST these are represented as\nan array of ",(0,a.kt)("inlineCode",{parentName:"p"},"TSExpressionWithTypeArguments")," on the ",(0,a.kt)("inlineCode",{parentName:"p"},"extends")," property of an ",(0,a.kt)("inlineCode",{parentName:"p"},"interface"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"export default function transformer(file, { jscodeshift: j }, options) {\n  const source = j(file.source);\n\n  source\n    .find(j.TSInterfaceDeclaration, { id: { name: oldName }}) // Find all TSInterfacDeclarations with the name \"Lunch\"\n    .forEach(path => path.node.extends = [ // Replace the extisting extends property\n        j.tsExpressionWithTypeArguments(j.identifier('Snacks')), // Create a new `TSExoressionWithTypeArguments` array\n    ]);\n\n\n  return source.toSource();\n}\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Input:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"interface Snacks {\n  fries: string;\n}\n\ninterface Lunch {\n  cheese: string;\n  burger: number;\n  icecream: string;\n}\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Output:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-diff"},"interface Snacks {\n  fries: string;\n}\n\n+interface Lunch extends Snacks {\n  cheese: string;\n  burger: number;\n  icecream: 'vanilla';\n}\n")),(0,a.kt)("h2",{id:"annotations"},"Annotations"),(0,a.kt)("h3",{id:"adding-types-to-variables"},"Adding types to variables"),(0,a.kt)("p",null,"Adding type annotations to an existing ",(0,a.kt)("inlineCode",{parentName:"p"},"VariableDeclarator")," involves assigning a type node\nto the ",(0,a.kt)("inlineCode",{parentName:"p"},"typeAnnotation")," property."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"export default function transformer(file, { jscodeshift: j }, options) {\n  const source = j(file.source);\n\n  source\n    .find(j.VariableDeclarator)\n    .find(j.Identifier, { name: 'dog' }) // Filter by name === 'dog'\n    // Add a typeAnnotation property to the node\n    .forEach(path => path.node.typeAnnotation = j.tsTypeAnnotation(j.tsStringKeyword()));\n\n  return source.toSource();\n}\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Input:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"const dog = 'Poodle';\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Output:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-diff"},"-const dog = 'Poodle';\n+const dog: string = 'Poodle';\n")))}d.isMDXComponent=!0}}]);