"use strict";(self.webpackChunkcodeshift_community=self.webpackChunkcodeshift_community||[]).push([[6156],{3905:function(e,t,n){n.d(t,{Zo:function(){return l},kt:function(){return f}});var o=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},s=Object.keys(e);for(o=0;o<s.length;o++)n=s[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(o=0;o<s.length;o++)n=s[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=o.createContext({}),p=function(e){var t=o.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},l=function(e){var t=p(e.components);return o.createElement(c.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},m=o.forwardRef((function(e,t){var n=e.components,r=e.mdxType,s=e.originalType,c=e.parentName,l=i(e,["components","mdxType","originalType","parentName"]),u=p(n),m=r,f=u["".concat(c,".").concat(m)]||u[m]||d[m]||s;return n?o.createElement(f,a(a({ref:t},l),{},{components:n})):o.createElement(f,a({ref:t},l))}));function f(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=n.length,a=new Array(s);a[0]=m;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i[u]="string"==typeof e?e:r,a[1]=i;for(var p=2;p<s;p++)a[p]=n[p];return o.createElement.apply(null,a)}return o.createElement.apply(null,n)}m.displayName="MDXCreateElement"},8413:function(e,t,n){n.r(t),n.d(t,{assets:function(){return c},contentTitle:function(){return a},default:function(){return d},frontMatter:function(){return s},metadata:function(){return i},toc:function(){return p}});var o=n(3117),r=(n(7294),n(3905));const s={id:"css-codemods",title:"CSS codemods via PostCSS",slug:"/css-codemods",description:"Learn how to create CSS codemods. This page covers the process of writing codemods that can automatically refactor CSS stylesheets, including tips and best practices for working with CSS and creating maintainable codemods.",keywords:["stylesheets","postcss","stylus","css-in-js"]},a=void 0,i={unversionedId:"guides/css-codemods",id:"guides/css-codemods",title:"CSS codemods via PostCSS",description:"Learn how to create CSS codemods. This page covers the process of writing codemods that can automatically refactor CSS stylesheets, including tips and best practices for working with CSS and creating maintainable codemods.",source:"@site/docs/guides/css-codemods.mdx",sourceDirName:"guides",slug:"/css-codemods",permalink:"/docs/css-codemods",draft:!1,editUrl:"https://github.com/hypermod-io/hypermod-community/edit/main/website/docs/guides/css-codemods.mdx",tags:[],version:"current",frontMatter:{id:"css-codemods",title:"CSS codemods via PostCSS",slug:"/css-codemods",description:"Learn how to create CSS codemods. This page covers the process of writing codemods that can automatically refactor CSS stylesheets, including tips and best practices for working with CSS and creating maintainable codemods.",keywords:["stylesheets","postcss","stylus","css-in-js"]},sidebar:"docs",previous:{title:"Prompting for human input",permalink:"/docs/prompting-for-human-input"},next:{title:"Integrating with monorepos",permalink:"/docs/monorepos"}},c={},p=[{value:"Step 1: Installing dependencies",id:"step-1-installing-dependencies",level:2},{value:"Step 2: Parsing",id:"step-2-parsing",level:2},{value:"Step 3: Transformation",id:"step-3-transformation",level:2},{value:"Step 4: Running",id:"step-4-running",level:2}],l={toc:p},u="wrapper";function d(e){let{components:t,...n}=e;return(0,r.kt)(u,(0,o.Z)({},l,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This page covers the process of writing codemods that can automatically refactor CSS stylesheets, including tips and best practices for working with CSS and creating maintainable codemods."),(0,r.kt)("p",null,"In some cases, it's possible that you may need to write a codemod that applies changes across different programming languages JS, CSS, etc.\nIt could be because the package you're writing a codemod for has an API that spans across both JS and CSS, for example a Design System or CSS-in-JS library. Where some of your consumers may be using the JS interface and some the CSS interface."),(0,r.kt)("p",null,"In this scenario, it's possible to repurpose JSCodeshift to handle this by treating JSCodeshift purely as a \"Runner\", or in other words, as the entrypoint to the files you're looking to modify and substitute a transformation library of your choice.\nFor example ",(0,r.kt)("a",{parentName:"p",href:"https://postcss.org/"},"PostCSS"),", ",(0,r.kt)("a",{parentName:"p",href:"https://babeljs.io/"},"Babel"),", etc."),(0,r.kt)("p",null,"However, this does come with drawbacks, you will no longer have access to JSCodeshift parsers and transformation API. This guide will explain how to handle these yourself."),(0,r.kt)("p",null,"As an example, We'll take the JS/CSS use-case and use the popular ",(0,r.kt)("a",{parentName:"p",href:"https://postcss.org/"},"PostCSS")," library as our substitute transformation library."),(0,r.kt)("h2",{id:"step-1-installing-dependencies"},"Step 1: Installing dependencies"),(0,r.kt)("p",null,"Get started by creating a new Hypermod package with ",(0,r.kt)("inlineCode",{parentName:"p"},"npx @hypermod/cli init --package-name css-codemod --preset update-css-api ."),"."),(0,r.kt)("p",null,"This will create a new Hypermod package with a configuration file and empty transform file for the preset you specified."),(0,r.kt)("p",null,"Navigate into your new directory with ",(0,r.kt)("inlineCode",{parentName:"p"},"cd css-codemod")," and install the relevant dependencies: ",(0,r.kt)("inlineCode",{parentName:"p"},"npm install -s postcss")),(0,r.kt)("h2",{id:"step-2-parsing"},"Step 2: Parsing"),(0,r.kt)("p",null,"Now navigate to your transformer file, which should look something like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"export default function transformer(file, { jscodeshift: j }, options) {\n  const source = j(file.source);\n\n  // Transformation goes here\n\n  return source.toSource(options.printOptions);\n}\n")),(0,r.kt)("p",null,"You can remove the following lines:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-diff"},"export default function transformer(\n  file,\n-  { jscodeshift: j },\n-  options\n) {\n-  const source = j(file.source);\n\n  // Transformation goes here\n\n-  return source.toSource(options.printOptions);\n}\n")),(0,r.kt)("p",null,"Now that we've removed JSCodeshift's parsing and output API, we can substitute PostCSS:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-diff"},"+ import postcss from 'postcss';\n\nexport default function transformer(file) {\n+  return await postcss([plugin()]).process(file.source).css;\n}\n")),(0,r.kt)("p",null,"Here we set up PostCSS with a ",(0,r.kt)("inlineCode",{parentName:"p"},"plugin()")," (more on that later) and pass in the raw file ",(0,r.kt)("inlineCode",{parentName:"p"},"file.source")," for processing.\nOnce processing is complete we return the raw file back to JSCodeshift for output via ",(0,r.kt)("inlineCode",{parentName:"p"},".css"),"."),(0,r.kt)("h2",{id:"step-3-transformation"},"Step 3: Transformation"),(0,r.kt)("p",null,"Now that we've setup parsing we can turn our attention to transformation. The way that can be done in PostCSS is via ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/postcss/postcss/blob/main/docs/writing-a-plugin.md"},"their plugin system"),"."),(0,r.kt)("p",null,"For example purposes, our transformation will simply reverse the names of CSS declarations like so:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-diff"},".my-class {\n- background: red;\n+ dnuorgkcab: red;\n}\n")),(0,r.kt)("p",null,"Very useful. Let's create the ",(0,r.kt)("inlineCode",{parentName:"p"},"plugin()")," function that does this now."),(0,r.kt)("p",null,"To assist with writing PostCSS plugins, you can use ",(0,r.kt)("a",{parentName:"p",href:"https://astexplorer.net/#/2uBU1BLuJ1"},"astexplorer.net"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const plugin = (): Plugin => {\n  const processed = Symbol('processed');\n\n  return {\n    postcssPlugin: 'UsingTokens',\n    Declaration: decl => {\n      if (decl[processed]) return;\n\n      decl.prop = decl.prop.split('').reverse().join('');\n\n      decl[processed] = true;\n    },\n  };\n};\n")),(0,r.kt)("h2",{id:"step-4-running"},"Step 4: Running"),(0,r.kt)("p",null,"You've created your very first CSS codemod, nice work! We can now run it against some code to verify that's it's working correctly."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"npx @hypermod/cli -t css-codemod/src/update-css-api.ts -e css path/to/src\n")))}d.isMDXComponent=!0}}]);